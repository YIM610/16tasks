## Dijkstra算法与最佳优先搜索

Dijkstra算法从物体所在的初始点开始，访问图中节点，迭代检查结点集中的节点，并把和该结点最靠近的尚未加入结点集的结点加入结点集。该结点集从初始结点向外扩展，直到到达目标结点。Dijstra算法能够保证找到一条从初始点到目标点的最短路径，只要所有的边都有一个非负的代价值。

![Dijkstra算法扫过的区域](http://theory.stanford.edu/~amitp/game-programming/a-star/dijkstra.png)

最佳优先搜索(BFS)算法按照类似的流程运行，不同的是它能够评估(称为启发式的)任意结点到目标结点的代价。与选择离初始结点最近的结点不同的是，它选择离目标最近的结点。BFS不能保证找到一条最短路径。然而，它比Dijkstra算法快的多，因为它用了一个启发式函数(heuristic function)快速地导向目标结点。例如，如果目标位于出发点地南方，BFS将趋向于导向南方地路径。

![BFS算法扫过的区域](http://theory.stanford.edu/~amitp/game-programming/a-star/best-first-search.png)

比较两个算法扫过的区域，就知道BFS
比Dijstra运行得更快。

当地图中有障碍物的时候。Dijstra算法运行得较慢，但确实能保证找到一条最短路径：

![](http://theory.stanford.edu/~amitp/game-programming/a-star/dijkstra-trap.png)

另一方面，BFS运行得较快，但是它找到得路径不一定是一条好路径：

![](http://theory.stanford.edu/~amitp/game-programming/a-star/best-first-search-trap.png)

**问题在于BFS是基于贪心策略的，它仅仅考虑到了到达目标的代价，而忽略了当前已花费的代价，所以尽管路径变得很长，它任然继续走下去**

## A*算法

A\*算法是把启发式方法如BFS，和常规方法如Dijstra算法结合在一起的算法。有点不同的是，类似BFS的启发式方法经常给出一个近似解而不是保证最佳解，A\*却能保证找到一条最短路径。

在简单的情况中，它和BFS一样快

![](http://theory.stanford.edu/~amitp/game-programming/a-star/a-star.png)

在凹形障碍物的例子中，A\*找到一条和Dijstra算法一样好的路径：

![](http://theory.stanford.edu/~amitp/game-programming/a-star/a-star-trap.png)

成功的秘诀在于，它把Dijkstra算法(靠近初始结点)和BFS算法(靠近目标结点)的信息块结合起来。在讨论A\*的标准术语中，g(n)表示从初始结点到任意检点n的代价，h(n)代表从结点n到目标点的启发式评估代价。A\*权衡这两者，每次进行主循环的时候，它检查f(n)最小的结点n，其中f(n)=g(n)+h(n)。

### 启发式算法

启发式函数h(n)告诉A\*从任意结点n到目标结点的最小评估值。选择一个好的启发式函数是重要的。

启发式函数可以控制A\*的行为：

* 如果h(n)是0，则只有g(n)起作用，此时A\*演变成Dijkstra算法，能保证找到最短路径。
* 如果h(n)经常都比从n移动到目标的实际代价小(或者相等)，则A\*保证能找到一条最短路径。h(n)越小，A\*扩展的结点越多，运行得就越慢。
* 如果h(n)精确地等于从n移动到目标的代价，则A\*将会仅仅寻找最佳路径而不扩展别的任何结点，这会运行得非常快。尽管这不可能在所有情况下发生，但我们仍可以在一些特殊情况下让它们精确地相等。只要提供完美地信息，A\*会运行得非常完美。
* 如果h(n)有时比从n移动到目标得实际代价高，则A*不能保证找到一条最短路径，但它会运行得更快。
* 如果h(n)比g(n)大很多，则只有h(n)起作用，A\*演变成BFS算法。

有的情况下，可以基于CPU的速度，地图上物体的数量，物体的重要性，组的大小，难度或其他任何因素来进行动态的选择。取得动态的折衷的一个方法是，建立一个启发式函数用于假定通过一个网格空间的最小代价是1，然后建立一个代价函数用于测量：

g`(n)=1+alpha*(g(n)-1)

如果alpha是0，则改进后的代价函数的总值是1。这种情况下，地形代价被完全忽略，A\*工作变成简单地判断一个网格可否通过。如果alpha为1，则最初的代价函数将起作用。

----

A\*计算f(n)=g(n)+h(n)。为了对这两个值进行相加，他们必须使用相同的衡量单位，如果g(n)用小时,h(n)用米来衡量，那么A\*将会认为g或h太大或者太小，因此不能得到正确的路径，同时算法将运行得更慢。

#### 网格地图中的启发式算法

考虑我们的代价函数并找到一个从一个位置移动到邻近位置的最小代价D

1. 曼哈顿距离：
	
	H(n)=D*(abs(n.x-goal.x)+abs(n.y-goal.y))

2. 对角线距离：

	如果地图中允许对角运动，那么我们需要一个不同的启发函数：h(n)=D*max(abs(n.x-goal.x),abs(n.y-goal.y))。如果对角线的代价不是D，但类似于D2=sqrt(2)*D。则我们可以修改启发函数让其更准确：
	
	h_diagonal(n)=min(abs(n.x-goal.x),abs(n.y-goal.y))

	h_straight(n)=(abs(n.x-goal.x)+abs(n.y-goal.y))

	h(n)=D2\*h\_diagonal(n)+D\*(h\_straight()-2\*h\_diagonal(n))

	这里我们计算h\_diagonal(n):沿着斜线可以移动的步数。h\_straightn(n):曼哈顿距离。然后合并这两项，让所有的斜线步数都乘以D2，剩下的所有直线步数都乘以D。
3. 欧几里得距离
	如果我们的单位可以沿着任意角度移动，那么我们应该使用直线距离：
	
	h(n)=D*sqrt((n.x-goal.x)^2+(n.y-goal.y)^2)

	因为欧几里得距离比曼哈顿距离和对角线距离都短，因此A\*会运行得更久一点，但是我们仍可以得到最短路径

### 性能问题

导致A\*低性能的一个原因是，当某些路径具有相同的f值的时候，他们都会被搜索，尽管我们只需要搜索其中的一条。为了解决这个问题，我们可以为启发函数添加一个附加值。附加值对于结点必须是确定的，而且让它必须让f值凸显区别。

一种添加附加值的方法是稍微改变h的衡量单位。如果我们减少衡量单位，那么当我们朝着目标移动的时候f将逐渐增加。但是这样会让A\*倾向于扩展到靠近初始点的结点，而不是靠近目标的结点。

heuristic *= (1.0 + p)

p这里称为选择因子，假设你不希望你的路径超过1000步，可以使p = 1 / 1000。添加这个附加值的结果是，A*比以前搜索的结点更少了。

一个不同的添加附加值的方法是，倾向于从初始点到目标点的连线（直线）：

dx1 = current.x - goal.x

dy1 = current.y - goal.y

dx2 = start.x - goal.x

dy2 = start.y - goal.y

cross = abs(dx1*dy2 - dx2*dy1)

heuristic += cross*0.001

[A*算法详细过程](http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html)